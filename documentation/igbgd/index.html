<html>
<head>
<title>igbgd</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
      integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
      crossorigin=""/>
 <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
         integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
         crossorigin=""></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>

<style>
#mapid   { height: 720px; }
table    { width: 360px; }
td       { vertical-align: top; }
td.key   { width: 100px; }
td.photo { text-align: center; width: 350px; }
</style>
</head>

<body>

<div id='mapid'>
<script type="text/javascript">
const config = {
  interval: 30 * 1000
}

const features = {}
const underscore = _

let map
let firstP = true

const init = () => {
  const URL = window.location.origin + '/v1/regions'
  $.get(URL).done((regions) => {
    let choice

    if (regions.length === 0) return alert('fatal! no regions defined')

    regions.forEach((region) => {
      if (region.regionID === 'igbgd.ky.green-iguana') choice = region
    })
    if (!choice) choice = regions[0]

    config.URL = window.location.origin + '/v1/region/' + choice.regionID+ '/entries'
    underscore.extend(config, choice)
    console.log('!!! init: ' + JSON.stringify(config, null, 2))
    if ((!config.view.options.google_token) && (!config.view.options.google_token)) {
      return alert('fatal! neither Google nor mapbox configured')
    }

    setTimeout(init2, 0)
  }).fail((jqXHR, statusText, errorText) => {
    alert('fatal! unable to fetch regions: ' + JSON.stringify(jqXHR, null, 2))
  })
}

const init2 = () => {
  map = L.map('mapid').setView([ config.view.center.latitude, config.view.center.longitude ], config.view.zoom)

  const google_options = {
    attribution: '<a href="' + window.location.origin + '/documentation" target="_blank">igbgd console</a>',
    subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
  }

  const mapbox_options = {
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
                 '<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
                 'Imagery &copy; <a href="https://www.mapbox.com/">Mapbox</a>, &hellip; ' +
                 '<a href="' + window.location.origin + '/documentation" target="_blank">igbgd console</a>',

/*
    cf., https://docs.mapbox.com/api/maps/#mapbox-styles

    id: 'mapbox/streets-v11'
    id: 'mapbox/navigation-preview-day-v4'
    id: 'mapbox/navigation-guidance-day-v4'
 */
    id: 'mapbox/outdoors-v11'
  }

  if (config.view.options.google_token) {
    L.tileLayer(`http://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}?key=${config.view.options.google_token}`,
                underscore.extend({ maxZoom: 18 }, google_options)).addTo(map)
  } else {
    L.tileLayer(`https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${config.view.options.mapbox_token}`,
                underscore.extend({ maxZoom: 18 }, mapbox_options)).addTo(map)
  }

  setTimeout(fetchFeatures, 0)
}

const fetchFeatures = () => {
  $.get(config.URL).done((entries) => {
    console.log('!!! ' + entries.length + ' matches.')
    underscore.keys(features).forEach((id) => {
      features[id].properties.seenP = false
    })

    let dropP = true
    entries.forEach((entry) => {
      if ((!firstP) && (!dropP)) {
        dropP = true
        return
      }

      const photo = 'data:image/' + entry.image.format + ';base64,' + entry.image.data;

      let feature, marker
      let newP = false,
          updateP = false

      if (features[entry.publicID]) {
        feature = features[entry.publicID]
        marker = feature.properties.leaflet.marker

        if (feature.properties.description !== entry.description) {
          updateP = true
          console.log('!!! description changed: ' + feature.properties.description + ' vs. ' + entry.description)

          feature.properties.description = entry.description
        }

        if (!underscore.isEqual(feature.properties.image, entry.image)) {
          updateP = true
          console.log('!!! image changed')

          feature.properties.image = entry.image
          feature.properties.leaflet.photo = photo
          marker.setIcon(L.icon({
            iconUrl: photo,
            iconSize: [ 24, 24 ],
            iconAnchor: [ 0, 0 ],
            popupAnchor: [ 12, 0 ]
          }))
        }

        const coordinates = [ entry.location.latitude, entry.location.longitude ]
        if (!underscore.isEqual(feature.geometry.coordinates, coordinates)) {
          console.log('!!! coordinates changed: ' + JSON.stringify(feature.geometry.coordinates) + ' vs. ' +
                      JSON.stringify(entry.location))

          feature.geometry.coordinates = coordinates
          marker.setLatLng(coordinates)
        }
      } else {
        newP = true

        feature = {
          type: 'feature',
          geometry: { type: 'Point', coordinates: [ entry.location.latitude, entry.location.longitude ] },
          properties: underscore.extend(underscore.omit(entry, [ 'location' ]), {
            leaflet: { photo: photo }
          })
        }
        
        features[entry.publicID] = feature
        console.log('!!! add ' + JSON.stringify(feature, null, 2))
        marker = L.marker(feature.geometry.coordinates, {
          icon: L.icon({
            iconUrl: photo,
            iconSize: [ 24, 24 ],
            iconAnchor: [ 0, 0 ],
            popupAnchor: [ 12, 0 ]
          })
        }).addTo(map)
        feature.properties.leaflet.marker = marker
      }

      if (newP || updateP) fetchLocation(feature)

      features[entry.publicID].properties.seenP = true
    })

    underscore.keys(features).forEach((id) => {
      feature = features[id]

      if (!feature.properties.seenP) {
        console.log('!!! remove ' + JSON.stringify(underscore.omit(feature, [ 'properties' ]), null, 2))

        map.removeLayer(feature.properties.leaflet.marker)
        delete features[id]
      }
    })

    firstP = false
    setTimeout(fetchFeatures, config.interval)
  }).fail((jqXHR, statusText, errorText) => {
// TBD: do something here later on...
    console.log('!!! fail: jqXHR=' + JSON.stringify(jqXHR, null, 2))

    setTimeout(fetchFeatures, config.interval)
  })
}

// Entry details popup...
const fetchLocation = (feature) => {
  const b = (s) => { return underscore.escape(s).replace(/, /g, '<br/>') }

  const marker = feature.properties.leaflet.marker
  const photo = feature.properties.leaflet.photo
  const maxwidth = 240

  let width = feature.properties.image.width
  let height = feature.properties.image.height
  if (width > maxwidth) {
    height = Math.round(height * (maxwidth / width))
    width = maxwidth
  }

  const latitude = feature.geometry.coordinates[0]
  const longitude = feature.geometry.coordinates[1]
  const working = '<i>working...</i>'

  let popupMarkup = '<div class="popup">'
          + '<table>' 
          + '<tr><td colspan="2">'
          +     underscore.escape(feature.properties.description || 'no description')
          + '</td></tr><tr><td class="key">'
          +     'Estimated Location:</td><td>' + working
          + '</td></tr><tr><td class="key">'
          +     'Longitude:</td><td>' + longitude
          + '</td></tr><tr><td class="key">'
          +     'Latitude:</td><td>' + latitude
          + '</td></tr><tr><td class="key">'
          +     'Created:</td><td>' + b(new Date(feature.properties.metadata.created).toLocaleString())
      + '</td></tr>'
  if (feature.properties.metadata.created !== feature.properties.metadata.modified) {
    popupMarkup += '<tr><td class="key">'
                +     'Modified:</td><td>' + new Date(feature.properties.metadata.modified).toLocaleString()
                + '</td></tr>'
  }
  if (feature.properties.metadata.authority) {
    popupMarkup += '<tr><td>'
                +     'Authority:</td><td>' + underscore.escape(feature.properties.metadata.authority)
                + '</td></tr>'
  }
  popupMarkup += '<tr><td class="key">'
          + '</td></tr><tr><td class="photo" colspan="2">'
          +     '<img src="' + photo + '" width="' + width + '" height="' + height + '" />'
          + '</td></tr>'
          + '</table></div>'
  feature.properties.leaflet.popupMarkup = popupMarkup

  marker.bindPopup(feature.properties.leaflet.popupMarkup)

  if (config.view.options.google_token) {
    $.get(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&result_type=subpremise|premise|street_address|point_of_interest&key=${config.view.options.google_token}`).done((result) => {
      const choices = {}

      if ((result.status !== 'OK') || (!result.results)) return console.log('!!! ' + JSON.stringify(result, null, 2))

      result.results.forEach((result) => {
        result.types.forEach((type) => {
          choices[type] = result.formatted_address
        })
      })

      const choice = choices.subpremise || choices.premise || choices.street_address || choices.point_of_interest || 'unknown'
      feature.properties.leaflet.popupMarkup = feature.properties.leaflet.popupMarkup.replace(working, b(choice))
      marker.bindPopup(feature.properties.leaflet.popupMarkup)
    })
  } else {
    $.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${longitude},${latitude}.json?types=locality,neighborhood,address,poi&access_token=${config.view.options.mapbox_token}`).done((result) => {
      const choices = {}

      if (!result.features) return console.log('!!!' + JSON.stringify(result, null, 2))

      result.features.forEach((feature) => {
        feature.place_type.forEach((type) => {
          choices[type] = feature.place_name
        })
      })

      const choice = choices.subpremise || choices.locality || 'unknown'
      feature.properties.leaflet.popupMarkup = feature.properties.leaflet.popupMarkup.replace(working, b(choice))
      marker.bindPopup(feature.properties.leaflet.popupMarkup)
    })
  }
}

$(() => {
  console.log('!!! loaded.')
  init()
})
</script>
</div>
</body>
</html>
